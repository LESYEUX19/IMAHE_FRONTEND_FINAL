@page "/sort"
@using System.Diagnostics
@using System.IO
@using System.Threading
@using System.Text.Json
@using System.Text.Json.Serialization
@using System.Net.Http.Json
@using CommunityToolkit.Maui.Storage
@using Imahe
@using Microsoft.Extensions.Logging
@using System.Drawing;
@using System.Drawing.Imaging;

@inject HttpClient Http
@inject AppState AppState
@inject ILogger<Sort> Logger
@implements IDisposable

<div class="sort-page-container">
    <div class="image-upload-main-layout">
        <div class="image-large-preview-panel">
            @if (imagePreviews.Count > 0 && selectedIndex < imagePreviews.Count)
            {
                <div class="image-large-preview-card">
                    <img src="@imagePreviews[selectedIndex].HighResDataUrl" alt="@imagePreviews[selectedIndex].FileName" class="image-large-preview-img" />
                    <div class="image-large-info">
                        <div class="file-name">@imagePreviews[selectedIndex].FileName</div>
                        <div class="file-size">@FormatFileSize(imagePreviews[selectedIndex].FileSize)</div>
                        @if (imagePreviews[selectedIndex].ClassificationResult != null)
                        {
                            <div class="classification-details">
                                <div class="details-summary @GetBadgeClass(imagePreviews[selectedIndex].ClassificationResult.Label)">
                                    @((MarkupString)imagePreviews[selectedIndex].ClassificationResult.GetDetailsSummary())
                                </div>
                            </div>
                        }
                    </div>
                </div>
            }
            else
            {
                <div class="image-large-preview-placeholder"><span class="placeholder-icon">🖼️</span><div class="placeholder-text">No image selected</div></div>
            }
        </div>
        <div class="image-upload-side-panel">
            <div class="controls-box">
                <h3 class="controls-title">Process Folder Images</h3>
                <div class="folder-selection"><button class="btn btn-primary w-100" @onclick="SelectInputFolder" disabled="@isProcessingAny">Choose Input Folder</button><code class="folder-path-display mt-2">@inputFolderPath</code></div>
                <div class="folder-selection"><button class="btn btn-primary w-100" @onclick="SelectOutputFolder" disabled="@isProcessingAny">Choose Output Folder</button><code class="folder-path-display mt-2">@outputFolderPath</code></div>
                <button class="process-btn" @onclick="StartProcessing" disabled="@(string.IsNullOrEmpty(inputFolderPath) || inputFolderPath.Contains("not selected") || string.IsNullOrEmpty(outputFolderPath) || outputFolderPath.Contains("not selected") || isProcessingAny)">
                    @if (isProcessingAny)
                    {
                        <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
                        <span class="ms-2">Processing...</span>
                    }
                    else
                    {
                        <span>▶ Start Processing</span>
                    }
                </button>
                <div class="progress-container"><div class="progress-bar-custom" style="width: @(totalFiles > 0 ? (processedCount * 100 / totalFiles) : 0)%"></div><span class="progress-label">@processedCount / @totalFiles</span></div>
                @if (!string.IsNullOrEmpty(formattedDuration))
                {
                    <div class="duration-display"><strong>Total Time: @formattedDuration</strong></div>
                }
                @if (!isProcessingAny && processedCount > 0 && processedCount == totalFiles)
                {
                    <button class="btn btn-success view-results-btn w-100" @onclick="OpenOutputFolder">📂 View Results</button>
                }
            </div>
            <div class="alert-container">
                @if (!string.IsNullOrEmpty(errorMessage))
                {
                    <div class="alert alert-danger" @onclick="ClearError" style="cursor: pointer;">@errorMessage</div>
                }
            </div>
            @if (imagePreviews.Count > 0)
            {
                <div class="thumbnail-scroll-box">
                    @foreach (var preview in imagePreviews)
                    {
                        <div class="image-thumbnail-card @(selectedIndex == imagePreviews.IndexOf(preview) ? "selected" : "")" @onclick="() => SelectPreview(imagePreviews.IndexOf(preview))">
                            <img src="@preview.ImageDataUrl" alt="@preview.FileName" class="image-thumbnail-img" />
                            <div class="thumbnail-info">
                                <span class="thumbnail-filename">@preview.FileName</span>

                                <!-- THE DEFINITIVE FIX IS HERE: Replaced dropdown with a simple div -->
                                @if (preview.ClassificationResult != null)
                                {
                                    <div class="classification-badge @GetBadgeClass(preview.ClassificationResult.Label)">
                                        @preview.ClassificationResult.Label
                                    </div>
                                }
                            </div>
                        </div>
                    }
                </div>
            }
        </div>
    </div>
</div>

<style>
    /* STYLES ARE UNCHANGED FROM YOUR WORKING VERSION */
    .classification-badge.dropdown-toggle {
        border: none;
        padding-right: 20px;
    }

        .classification-badge.dropdown-toggle::after {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
        }

    .details-summary {
        text-align: left;
        line-height: 1.6;
    }

        .details-summary strong {
            color: #343a40;
        }

    .sort-page-container {
        padding: 1.5rem;
    }

    .image-upload-main-layout {
        display: flex;
        flex-wrap: wrap;
        gap: 2rem;
    }

    .image-large-preview-panel {
        flex: 3;
        min-width: 350px;
    }

    .image-upload-side-panel {
        flex: 2;
        min-width: 320px;
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
    }

    .controls-box {
        display: flex;
        flex-direction: column;
        gap: 1.25rem;
        padding: 1.5rem;
        background-color: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 8px;
    }

    .controls-title {
        margin-bottom: 0;
    }

    .folder-path-display {
        display: block;
        padding: 0.5rem 0.75rem;
        background-color: #e9ecef;
        border: 1px solid #ced4da;
        border-radius: 4px;
        font-size: 0.85rem;
        color: #495057;
        word-break: break-all;
    }

    .progress-container {
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 100%;
        height: 28px;
        background-color: #e9ecef;
        border-radius: 8px;
        overflow: hidden;
    }

    .progress-bar-custom {
        position: absolute;
        top: 0;
        left: 0;
        height: 100%;
        background-image: linear-gradient(45deg, #20c997, #17a2b8);
        border-radius: 8px;
        transition: width 0.3s ease-in-out;
    }

    .progress-label {
        position: relative;
        color: #343a40;
        font-weight: bold;
        text-shadow: 0 0 2px white;
    }

    .duration-display {
        text-align: center;
        font-size: 0.9rem;
        color: #6c757d;
    }

    .thumbnail-scroll-box {
        height: 400px;
        overflow-y: auto;
        border: 1px solid #dee2e6;
        padding: 10px;
        background-color: #f8f9fa;
        display: flex;
        flex-direction: column;
        gap: 12px;
        flex-grow: 1;
        border-radius: 8px;
    }

    .image-thumbnail-card {
        display: flex;
        align-items: center;
        gap: 16px;
        padding: 12px;
        border-radius: 8px;
        border: 1px solid #ced4da;
        background-color: #ffffff;
        transition: all 0.2s ease-in-out;
        cursor: pointer;
    }

        .image-thumbnail-card.selected {
            border-color: #0d6efd;
            box-shadow: 0 0 8px rgba(13, 110, 253, 0.4);
            transform: scale(1.02);
        }

    .image-thumbnail-img {
        width: 80px;
        height: 80px;
        object-fit: cover;
        border-radius: 6px;
        flex-shrink: 0;
        background-color: #e9ecef;
    }

    .thumbnail-info {
        display: flex;
        flex-direction: column;
        justify-content: center;
        gap: 8px;
        overflow: hidden;
        flex-grow: 1;
    }

    .thumbnail-filename {
        font-weight: 600;
        font-size: 0.9rem;
        color: #212529;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .classification-badge {
        padding: 4px 12px;
        border-radius: 15px;
        font-size: 0.85rem;
        font-weight: 700;
        color: white;
        align-self: flex-start;
    }

    .badge-good {
        background-color: #198754;
    }

    .badge-bad, .badge-blurred {
        background-color: #dc3545;
    }

    .badge-focused {
        background-color: #0dcaf0;
    }

    .badge-closed-eye {
        background-color: #fd7e14;
    }

    .badge-duplicate {
        background-color: #6c757d;
    }

    .badge-default {
        background-color: #6c757d;
    }

    .details-summary.badge-good {
        color: #0f5132;
        background-color: #d1e7dd;
        border-color: #badbcc;
    }

    .details-summary.badge-bad {
        color: #664d03;
        background-color: #fff3cd;
        border-color: #ffecb5;
    }

    .details-summary.badge-blurred {
        color: #58151c;
        background-color: #f8d7da;
        border-color: #f1aeb5;
    }

    .details-summary.badge-focused {
        color: #052c65;
        background-color: #cce5ff;
        border-color: #b6d4fe;
    }

    .details-summary.badge-closed-eye {
        color: #513005;
        background-color: #fff0c2;
        border-color: #ffe6a0;
    }

    .details-summary.badge-duplicate, .details-summary.badge-default {
        color: #212529;
        background-color: #e2e3e5;
        border-color: #d3d6d8;
    }
</style>

@code {
    private string inputFolderPath = "Input folder not selected";
    private string outputFolderPath = "Output folder not selected";
    private List<ImagePreview> imagePreviews = new();
    private string errorMessage = "";
    private bool isProcessingAny = false;
    private int processedCount = 0;
    private int totalFiles = 0;
    private Stopwatch processingStopwatch = new Stopwatch();
    private string formattedDuration = "";
    private int selectedIndex = 0;
    private readonly string[] ClassificationFolders = { "Good", "Focused", "Blurred", "Closed Eye", "Duplicate" };
    private readonly string[] AllowedExtensions = { ".jpg", ".jpeg", ".png", ".bmp", ".webp" };
    private Timer? uiUpdateTimer;

    protected override void OnInitialized()
    {
        uiUpdateTimer = new Timer(async _ =>
        {
            await InvokeAsync(StateHasChanged);
        }, null, Timeout.Infinite, Timeout.Infinite);
    }

    public void Dispose() => uiUpdateTimer?.Dispose();

    private string CreateThumbnailDataUrl(byte[] imageBytes, int width, int height) { try { using var ms = new MemoryStream(imageBytes); using var image = Image.FromStream(ms); var ratioX = (double)width / image.Width; var ratioY = (double)height / image.Height; var ratio = Math.Min(ratioX, ratioY); var newWidth = (int)(image.Width * ratio); var newHeight = (int)(image.Height * ratio); using var newImage = new Bitmap(newWidth, newHeight); using var graphics = Graphics.FromImage(newImage); graphics.CompositingQuality = System.Drawing.Drawing2D.CompositingQuality.HighSpeed; graphics.InterpolationMode = System.Drawing.Drawing2D.InterpolationMode.Low; graphics.SmoothingMode = System.Drawing.Drawing2D.SmoothingMode.HighSpeed; graphics.DrawImage(image, 0, 0, newWidth, newHeight); using var msThumbnail = new MemoryStream(); newImage.Save(msThumbnail, ImageFormat.Jpeg); return $"data:image/jpeg;base64,{Convert.ToBase64String(msThumbnail.ToArray())}"; } catch (Exception ex) { Logger.LogError(ex, "Failed to create thumbnail."); return string.Empty; } }

    private async Task ProcessFilesConcurrently(List<string> filePaths, string sessionId, CancellationToken cancellationToken)
    {
        var previewsToAdd = filePaths.Select(filePath => new ImagePreview { FileName = Path.GetFileName(filePath), SessionId = sessionId }).ToList();
        imagePreviews.AddRange(previewsToAdd);
        if (imagePreviews.Any()) { await SelectPreview(0); }

        uiUpdateTimer?.Change(TimeSpan.FromMilliseconds(250), TimeSpan.FromMilliseconds(250));

        var parallelOptions = new ParallelOptions { MaxDegreeOfParallelism = Environment.ProcessorCount, CancellationToken = cancellationToken };

        await Parallel.ForEachAsync(imagePreviews, parallelOptions, async (preview, token) =>
        {
            var sourceFilePath = Path.Combine(inputFolderPath, preview.FileName);
            try
            {
                if (!File.Exists(sourceFilePath)) { return; }
                var fileBytes = await File.ReadAllBytesAsync(sourceFilePath, token);
                preview.FileSize = fileBytes.Length;
                var extension = Path.GetExtension(preview.FileName).ToLowerInvariant();
                if (extension == ".webp") { preview.ImageDataUrl = $"data:image/webp;base64,{Convert.ToBase64String(fileBytes)}"; }
                else { preview.ImageDataUrl = CreateThumbnailDataUrl(fileBytes, 150, 150); }
                using var content = new MultipartFormDataContent();
                content.Add(new ByteArrayContent(fileBytes), "file", preview.FileName);
                content.Add(new StringContent(sessionId), "session_id");
                var response = await Http.PostAsync("http://localhost:8000/upload-image/", content, token);

                if (response.IsSuccessStatusCode)
                {
                    var options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
                    var uploadResponse = await response.Content.ReadFromJsonAsync<UploadResponsePayload>(options, token);
                    if (uploadResponse != null)
                    {
                        preview.ClassificationResult = uploadResponse.Classification;
                        preview.SanitizedFileName = uploadResponse.SanitizedFilename;
                        preview.ImageUrl = uploadResponse.ImageUrl;
                        if (ClassificationFolders.Contains(uploadResponse.Classification.Label))
                        {
                            (int width, int height) = GetImageDimensionsFromBytes(fileBytes);
                            string orientationFolder = width >= height ? "Landscape" : "Portrait";
                            var destinationFolder = Path.Combine(outputFolderPath, orientationFolder, uploadResponse.Classification.Label);
                            Directory.CreateDirectory(destinationFolder);
                            var destinationPath = Path.Combine(destinationFolder, uploadResponse.SanitizedFilename);
                            if (File.Exists(destinationPath)) { destinationPath = Path.Combine(destinationFolder, $"{Path.GetFileNameWithoutExtension(uploadResponse.SanitizedFilename)}_{DateTime.Now.Ticks}{Path.GetExtension(uploadResponse.SanitizedFilename)}"); }
                            File.Move(sourceFilePath, destinationPath);
                            preview.FinalPath = destinationPath;
                        }
                    }
                }
                else
                {
                    var errorContent = await response.Content.ReadAsStringAsync(token);
                    preview.ClassificationResult = new ClassificationResult { Label = "Error", Details = new ClassificationDetails { Message = errorContent } };
                }
            }
            catch (OperationCanceledException) { preview.ClassificationResult = new ClassificationResult { Label = "Cancelled" }; }
            catch (Exception ex) { Logger.LogError(ex, "A critical error occurred while processing {FileName}", preview.FileName); preview.HasError = true; preview.ErrorMessage = ex.Message; preview.ClassificationResult = new ClassificationResult { Label = "Error" }; }
            finally
            {
                Interlocked.Increment(ref processedCount);
            }
        });

        uiUpdateTimer?.Change(Timeout.Infinite, Timeout.Infinite);
        await InvokeAsync(StateHasChanged);
    }

    private async Task ReclassifyImage(ImagePreview preview, string newLabel) { if (preview.ClassificationResult == null || preview.ClassificationResult.Label == newLabel || string.IsNullOrEmpty(preview.ImageUrl)) return; string oldLabel = preview.ClassificationResult.Label; preview.ClassificationResult.Label = newLabel; preview.ClassificationResult.Details ??= new(); preview.ClassificationResult.Details.Message = $"Manually re-classified as {newLabel}."; await InvokeAsync(StateHasChanged); try { byte[] fileBytes = File.Exists(preview.FinalPath) ? await File.ReadAllBytesAsync(preview.FinalPath) : Array.Empty<byte>(); (int width, int height) = GetImageDimensionsFromBytes(fileBytes); string orientationFolder = width >= height ? "Landscape" : "Portrait"; var oldFolder = Path.Combine(outputFolderPath, orientationFolder, oldLabel); var newFolder = Path.Combine(outputFolderPath, orientationFolder, newLabel); Directory.CreateDirectory(newFolder); var oldPath = preview.FinalPath; if (File.Exists(oldPath)) { var finalFileName = Path.GetFileName(oldPath); var newPath = Path.Combine(newFolder, finalFileName); File.Move(oldPath, newPath); preview.FinalPath = newPath; } var updateRequest = new UpdateHistoryLabelRequest { Path = preview.ImageUrl, NewLabel = newLabel, NewDetailsMessage = preview.ClassificationResult.GetDetailsSummary() }; await Http.PutAsJsonAsync("http://localhost:8000/update-history-label/", updateRequest); } catch (Exception ex) { errorMessage = $"Failed to re-classify {preview.FileName}: {ex.Message}"; Logger.LogError(ex, "Re-classification failed for {FileName}", preview.FileName); } }
    private async Task SelectPreview(int index) { if (index < 0 || index >= imagePreviews.Count) return; if (selectedIndex < imagePreviews.Count) { imagePreviews[selectedIndex].ClearHighResData(); } selectedIndex = index; var selectedPreview = imagePreviews[selectedIndex]; var pathToLoad = selectedPreview.FinalPath ?? Path.Combine(inputFolderPath, selectedPreview.FileName); if (File.Exists(pathToLoad)) { var fileBytes = await File.ReadAllBytesAsync(pathToLoad); selectedPreview.SetHighResData(fileBytes); } else { selectedPreview.ClearHighResData(); } await InvokeAsync(StateHasChanged); }
    private async Task SelectInputFolder() { try { var result = await FolderPicker.Default.PickAsync(); if (result.IsSuccessful && result.Folder != null) inputFolderPath = result.Folder.Path; } catch { } }
    private async Task SelectOutputFolder() { try { var result = await FolderPicker.Default.PickAsync(); if (result.IsSuccessful && result.Folder != null) outputFolderPath = result.Folder.Path; } catch { } }
    private async Task StartProcessing() { if (string.IsNullOrWhiteSpace(inputFolderPath) || inputFolderPath.Contains("not selected") || string.IsNullOrWhiteSpace(outputFolderPath) || outputFolderPath.Contains("not selected")) { errorMessage = "Please select both input and output folders."; return; } var sessionId = Guid.NewGuid().ToString(); isProcessingAny = true; errorMessage = ""; processedCount = 0; selectedIndex = 0; imagePreviews.Clear(); processingStopwatch.Restart(); AppState.SetIsProcessing(true); if (AppState.ProcessingCancellationTokenSource is null) { AppState.SetIsProcessing(false); return; } try { await Http.PostAsync("http://localhost:8000/clear-state/", null, AppState.ProcessingCancellationTokenSource.Token); } catch (Exception ex) { Logger.LogWarning("Could not clear backend state: {Message}", ex.Message); } var filePaths = Directory.GetFiles(inputFolderPath).Where(f => AllowedExtensions.Contains(Path.GetExtension(f).ToLowerInvariant())).ToList(); totalFiles = filePaths.Count; if (totalFiles > 0) { await ProcessFilesConcurrently(filePaths, sessionId, AppState.ProcessingCancellationTokenSource.Token); } else { errorMessage = "No valid images found in the selected folder."; } processingStopwatch.Stop(); formattedDuration = $"{processingStopwatch.Elapsed:hh\\:mm\\:ss}"; isProcessingAny = false; AppState.SetIsProcessing(false); }
    private void OpenOutputFolder() { try { if (!string.IsNullOrEmpty(outputFolderPath) && Directory.Exists(outputFolderPath)) { Process.Start(new ProcessStartInfo { FileName = outputFolderPath, UseShellExecute = true }); } } catch (Exception ex) { errorMessage = $"Could not open folder: {ex.Message}"; } }
    private (int, int) GetImageDimensionsFromBytes(byte[] imageBytes) { try { if (imageBytes.Length == 0) return (0, 0); using var ms = new MemoryStream(imageBytes); using var image = Image.FromStream(ms); return (image.Width, image.Height); } catch { return (0, 0); } }
    private void ClearError() => errorMessage = "";
    private string GetBadgeClass(string? label) => string.IsNullOrEmpty(label) ? "badge-default" : $"badge-{label.ToLower().Replace(" ", "-")}";
    private string FormatFileSize(long bytes) { if (bytes <= 0) return "0 B"; string[] orders = { "B", "KB", "MB", "GB", "TB" }; var i = (int)Math.Floor(Math.Log(bytes, 1024)); return $"{bytes / Math.Pow(1024, i):F2} {orders[i]}"; }

    public class ImagePreview
    {
        public string FileName { get; set; } = "";
        public string ImageDataUrl { get; set; } = "";
        private byte[]? _highResBytes;
        public string HighResDataUrl => _highResBytes != null ? $"data:image/{Path.GetExtension(FileName).TrimStart('.').ToLower()};base64,{Convert.ToBase64String(_highResBytes)}" : ImageDataUrl;
        public long FileSize { get; set; }
        public ClassificationResult? ClassificationResult { get; set; }
        public bool HasError { get; set; }
        public string ErrorMessage { get; set; } = "";
        public string? FinalPath { get; set; }
        public string SessionId { get; set; } = "";
        public string? SanitizedFileName { get; set; }
        public string? ImageUrl { get; set; }
        public void SetHighResData(byte[] data) => _highResBytes = data;
        public void ClearHighResData() => _highResBytes = null;
        public byte[]? GetHighResBytes() => _highResBytes;
    }

    public class UploadResponsePayload { [JsonPropertyName("classification")] public ClassificationResult Classification { get; set; } = new(); [JsonPropertyName("sanitizedFilename")] public string SanitizedFilename { get; set; } = ""; [JsonPropertyName("imageUrl")] public string ImageUrl { get; set; } = ""; }
    public class ClassificationResult { [JsonPropertyName("label")] public string Label { get; set; } = ""; [JsonPropertyName("details")] public ClassificationDetails? Details { get; set; } public string GetDetailsSummary() { if (Details == null) return "No details available."; var summary = $"<strong>{Details.Message}</strong>"; switch (Label) { case "Good": case "Blurred": case "Focused": if (!string.IsNullOrEmpty(Details.Message)) summary += "<br />"; if (Details.Sharpness.HasValue) summary += $"Sharpness: {Details.Sharpness.Value:F1}<br />"; if (Details.Exposure.HasValue) summary += $"Exposure: {Details.Exposure.Value:F1}<br />"; break; case "Closed Eye": break; } return summary.TrimEnd(new[] { '<', 'b', 'r', ' ', '/' }); } }
    public class ClassificationDetails { [JsonPropertyName("message")] public string? Message { get; set; } [JsonPropertyName("sharpness")] public float? Sharpness { get; set; } [JsonPropertyName("exposure")] public float? Exposure { get; set; } [JsonPropertyName("faceCount")] public int? FaceCount { get; set; } [JsonPropertyName("isDuplicate")] public bool IsDuplicate { get; set; } [JsonPropertyName("hasClosedEyes")] public bool HasClosedEyes { get; set; } }
    public class UpdateHistoryLabelRequest { [JsonPropertyName("path")] public string Path { get; set; } = ""; [JsonPropertyName("newLabel")] public string NewLabel { get; set; } = ""; [JsonPropertyName("newDetailsMessage")] public string NewDetailsMessage { get; set; } = ""; }
}