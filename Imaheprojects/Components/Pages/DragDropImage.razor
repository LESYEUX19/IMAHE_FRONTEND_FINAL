
@using System.Diagnostics
@using System.Text.Json
@using System.IO
@using CommunityToolkit.Maui.Storage
@using Imahe
@using System.Threading
@using Microsoft.AspNetCore.Components

<div class="image-upload-main-layout">
    @* (No changes in this section) *@
    <div class="image-large-preview-panel">
        @if (imagePreviews.Count > 0 && selectedIndex < imagePreviews.Count)
        {
            <div class="image-large-preview-card">
                <img src="@imagePreviews[selectedIndex].ImageDataUrl" alt="@imagePreviews[selectedIndex].FileName" class="image-large-preview-img" />
                <div class="image-large-info">
                    <div class="file-name">@imagePreviews[selectedIndex].FileName</div>
                    <div class="file-size">@FormatFileSize(imagePreviews[selectedIndex].FileSize)</div>
                    @if (imagePreviews[selectedIndex].ClassificationResult != null)
                    {
                        <div class="classification-details">
                            <div class="details-summary @GetSummaryClass(imagePreviews[selectedIndex].ClassificationResult?.Label)">
                                @imagePreviews[selectedIndex].ClassificationResult?.GetDetailsSummary()
                            </div>
                        </div>
                    }
                </div>
            </div>
        }
        else
        {
            <div class="image-large-preview-placeholder">
                <span class="placeholder-icon">üñºÔ∏è</span>
                <div class="placeholder-text">No image selected</div>
            </div>
        }
    </div>
    <div class="image-upload-side-panel">
        <div class="image-upload-header">
            <h2 class="image-upload-title">Process Folder Images</h2>
            <p class="image-upload-desc">Select input and output folders to process and organize images.</p>
            <div class="folder-selection">
                <label><strong>Input Folder:</strong></label><br />
                <button class="btn btn-primary" @onclick="SelectInputFolder" disabled="@isProcessingAny">Choose Input Folder</button>
                <code class="folder-path-display">@inputFolderPath</code>
            </div>
            <div class="folder-selection">
                <label><strong>Output Folder:</strong></label><br />
                <button class="btn btn-primary" @onclick="SelectOutputFolder" disabled="@isProcessingAny">Choose Output Folder</button>
                <code class="folder-path-display">@outputFolderPath</code>
            </div>
            @if (!string.IsNullOrEmpty(outputFolderPath))
            {
                <p class="folder-info">Output subfolders will be created at:<br />@Path.Combine(outputFolderPath, "Landscape")<br />@Path.Combine(outputFolderPath, "Portrait")</p>
            }

            @* --- NEW: Section 1 - Conditionally show the 'Start' or 'Open Folder' button --- *@
            @if (showOpenFolderButton)
            {
                <button class="btn btn-success" @onclick="OpenResultsFolder">üìÇ Open Results Folder</button>
            }
            else
            {
                <button class="process-btn" @onclick="StartProcessing" disabled="@(string.IsNullOrEmpty(inputFolderPath) || string.IsNullOrEmpty(outputFolderPath) || isProcessingAny || !imagePreviews.Any())">‚ñ∂ Start Processing</button>
            }

            <div class="progress-bar">
                Processed: @processedCount / @totalFiles
                <progress value="@processedCount" max="@totalFiles"></progress>
            </div>

            @if (!string.IsNullOrEmpty(formattedDuration))
            {
                <div class="duration-display">
                    <strong>@formattedDuration</strong>
                </div>
            }
        </div>
        @* (No changes below this point in the HTML) *@
        <div class="alert-container">
            @if (!string.IsNullOrEmpty(errorMessage))
            {
                <div class="alert alert-danger" @onclick="ClearError" style="cursor: pointer;">
                    <div class="alert-content">
                        <div class="alert-icon">‚ö†Ô∏è</div>
                        <div class="alert-text"><strong>Error:</strong> @errorMessage</div>
                        <span class="alert-close" title="Dismiss">√ó</span>
                    </div>
                </div>
            }
            @if (showNotification)
            {
                <div class="alert alert-warning">
                    <div class="alert-content">
                        <div class="alert-icon">‚è≥</div>
                        <div class="alert-text"><strong>Processing in progress...</strong></div>
                    </div>
                </div>
            }
        </div>
        @if (imagePreviews.Count > 0)
        {
            <div class="thumbnail-scroll-box">
                <Virtualize Items="imagePreviews" Context="preview" OverscanCount="10">
                    <div class="image-thumbnail-card @(selectedIndex == imagePreviews.IndexOf(preview) ? "selected" : "") @(preview.HasError ? "error" : "")" @onclick="() => SelectPreview(imagePreviews.IndexOf(preview))">
                        <img src="@preview.ImageDataUrl" alt="@preview.FileName" class="image-thumbnail-img" />
                        @if (preview.IsProcessing)
                        {
                            <div class="processing-overlay"><div class="processing-spinner"></div></div>
                        }
                        else if (preview.HasError)
                        {
                            <div class="error-overlay"><div class="error-icon">‚ö†Ô∏è</div><span>@preview.ErrorMessage</span></div>
                        }
                        else if (preview.ClassificationResult != null)
                        {
                            <div class="classification-badge @GetBadgeClass(preview.ClassificationResult?.Label)">
                                @preview.ClassificationResult?.Label
                            </div>
                        }
                    </div>
                </Virtualize>
            </div>
        }
    </div>
</div>

<style>
    /* (No changes to your style block) */
    .thumbnail-scroll-box {
        height: 300px;
        overflow-y: auto;
        border: 1px solid #ccc;
        padding: 10px;
        flex-grow: 1;
    }

    .alert-container {
        margin-bottom: 10px;
        text-align: left;
    }

    .alert-close {
        cursor: pointer;
    }

    .duration-display {
        font-size: 0.9em;
        color: #333;
        margin-top: 8px;
        text-align: center;
    }

    .folder-path-display {
        display: block;
        background-color: #f4f4f4;
        border: 1px solid #ddd;
        border-radius: 4px;
        padding: 6px 10px;
        margin-top: 5px;
        font-family: monospace;
        word-wrap: break-word;
        min-height: 1.5em;
    }
</style>

@code {
    [Inject] private IJSRuntime JS { get; set; } = default!;
    [Inject] private HttpClient Http { get; set; } = default!;
    [Inject] private AppState AppState { get; set; } = default!;

    // (No changes to most properties)
    private string inputFolderPath = "";
    private string outputFolderPath = "";
    private List<ImagePreview> imagePreviews = new();
    private string errorMessage = "";
    private bool isProcessingAny = false;
    private bool showNotification = false;
    private int selectedIndex = 0;
    private int processedCount = 0;
    private int totalFiles = 0;
    private const long MaxFileSize = 1L * 1024 * 1024 * 1024;

    private Stopwatch processingStopwatch = new Stopwatch();
    private string formattedDuration = "";

    // --- NEW: Section 2 - Add a flag to control the button's visibility ---
    private bool showOpenFolderButton = false;

    private readonly string[] AllowedExtensions = { ".jpg", ".jpeg", ".png", ".gif", ".bmp", ".webp" };
    private readonly string[] ClassificationFolders = { "Good", "Bad", "Duplicate", "Closed Eye" };

    #region Core Logic

    private async Task SelectInputFolder()
    {
        // --- MODIFIED: Hide the button when a new folder is selected ---
        showOpenFolderButton = false;

        try
        {
            var result = await FolderPicker.Default.PickAsync(CancellationToken.None);
            if (result.IsSuccessful && result.Folder != null)
            {
                inputFolderPath = result.Folder.Path;
                errorMessage = "";
                await LoadImagePreviewsFromFolder(inputFolderPath);
            }
        }
        catch (Exception ex) { errorMessage = $"Error selecting folder: {ex.Message}"; }
        await InvokeAsync(StateHasChanged);
    }

    private async Task LoadImagePreviewsFromFolder(string folderPath)
    {
        imagePreviews.Clear();
        processedCount = 0;
        totalFiles = 0;
        selectedIndex = 0;
        await InvokeAsync(StateHasChanged);

        try
        {
            var filePaths = Directory.GetFiles(folderPath).Where(f => AllowedExtensions.Contains(Path.GetExtension(f).ToLowerInvariant())).ToList();
            totalFiles = filePaths.Count;
            if (totalFiles == 0)
            {
                errorMessage = "No valid images found in the input folder.";
                return;
            }
            foreach (var filePath in filePaths)
            {
                var fileInfo = new FileInfo(filePath);
                byte[] imageBytes = await File.ReadAllBytesAsync(filePath);
                string base64String = Convert.ToBase64String(imageBytes);
                string imageFormat = Path.GetExtension(filePath).TrimStart('.').ToLowerInvariant();
                if (imageFormat == "jpg") imageFormat = "jpeg";
                string imageDataUrl = $"data:image/{imageFormat};base64,{base64String}";
                imagePreviews.Add(new ImagePreview { FileName = fileInfo.Name, FileSize = fileInfo.Length, ImageDataUrl = imageDataUrl });
            }
        }
        catch (Exception ex) { errorMessage = $"Error loading previews: {ex.Message}"; }
        await InvokeAsync(StateHasChanged);
    }

    private async Task SelectOutputFolder()
    {
        // --- MODIFIED: Hide the button if the output folder changes ---
        showOpenFolderButton = false;

        try
        {
            var result = await FolderPicker.Default.PickAsync(CancellationToken.None);
            if (result.IsSuccessful && result.Folder != null)
            {
                outputFolderPath = result.Folder.Path;
                errorMessage = "";
            }
        }
        catch (Exception ex) { errorMessage = $"Error selecting folder: {ex.Message}"; }
        await InvokeAsync(StateHasChanged);
    }

    private async Task StartProcessing()
    {
        // --- MODIFIED: Hide the button when starting a new process ---
        showOpenFolderButton = false;

        if (string.IsNullOrWhiteSpace(inputFolderPath) || string.IsNullOrWhiteSpace(outputFolderPath))
        {
            errorMessage = "Please select valid input and output folders.";
            return;
        }

        formattedDuration = "";
        processingStopwatch.Restart();
        AppState.SetIsProcessing(true);
        isProcessingAny = true;
        showNotification = true;
        processedCount = 0;

        foreach (var p in imagePreviews)
        {
            p.HasError = false;
            p.ErrorMessage = "";
            p.ClassificationResult = null;
        }
        await InvokeAsync(StateHasChanged);

        try
        {
            try { await Http.PostAsync("http://localhost:8000/clear-state/", null); }
            catch (Exception ex) { errorMessage = $"Could not reset server cache: {ex.Message}"; }

            if (imagePreviews.Any())
            {
                await ProcessFilesConcurrently(AppState.ProcessingCancellationTokenSource!.Token);
            }
            else { errorMessage = "No images to process. Please select an input folder with images first."; }
        }
        catch (OperationCanceledException) { errorMessage = "Processing was canceled."; }
        catch (Exception ex) { errorMessage = $"An error occurred during processing: {ex.Message}"; }
        finally
        {
            processingStopwatch.Stop();
            var elapsed = processingStopwatch.Elapsed;
            formattedDuration = $"Total Time: {elapsed:mm\\:ss\\.fff}";
            AppState.SetIsProcessing(false);
            isProcessingAny = false;
            showNotification = false;

            // --- MODIFIED: Show the button now that processing is complete ---
            if (processedCount > 0)
            {
                showOpenFolderButton = true;
            }
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task ProcessFilesConcurrently(CancellationToken cancellationToken)
    {
        // (No changes in this method)
        var landscapeFolder = Path.Combine(outputFolderPath, "Landscape");
        var portraitFolder = Path.Combine(outputFolderPath, "Portrait");
        var parallelOptions = new ParallelOptions { MaxDegreeOfParallelism = Environment.ProcessorCount, CancellationToken = cancellationToken };
        await Parallel.ForEachAsync(imagePreviews, parallelOptions, async (preview, token) =>
        {
            var filePath = Path.Combine(inputFolderPath, preview.FileName);
            preview.IsProcessing = true;
            await InvokeAsync(StateHasChanged);
            try
            {
                if (preview.FileSize > MaxFileSize) throw new Exception("File size exceeds 1GB limit.");
                var fileBytes = await File.ReadAllBytesAsync(filePath, token);
                using var content = new MultipartFormDataContent();
                using var byteArrayContent = new ByteArrayContent(fileBytes);
                var extension = Path.GetExtension(preview.FileName).TrimStart('.').ToLower();
                byteArrayContent.Headers.ContentType = new System.Net.Http.Headers.MediaTypeHeaderValue($"image/{extension}");
                content.Add(byteArrayContent, "file", preview.FileName);
                var response = await Http.PostAsync("http://localhost:8000/upload-image/", content, token);
                var jsonOptions = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
                preview.ClassificationResult = response.IsSuccessStatusCode
                    ? await response.Content.ReadFromJsonAsync<ClassificationResult>(jsonOptions, cancellationToken: token)
                    : new ClassificationResult { Status = "Error", Label = "Error", Details = new ClassificationDetails { Message = $"Upload failed: {response.ReasonPhrase}" } };
                if (preview.ClassificationResult?.Label != null && ClassificationFolders.Contains(preview.ClassificationResult.Label))
                {
                    (int width, int height) = GetImageDimensionsFromBytes(fileBytes);
                    string orientation = width >= height ? "Landscape" : "Portrait";
                    var destinationFolder = Path.Combine(orientation == "Landscape" ? landscapeFolder : portraitFolder, preview.ClassificationResult.Label);
                    Directory.CreateDirectory(destinationFolder);
                    var destinationPath = Path.Combine(destinationFolder, preview.FileName);
                    if (File.Exists(destinationPath))
                    {
                        var baseName = Path.GetFileNameWithoutExtension(preview.FileName);
                        var ext = Path.GetExtension(preview.FileName);
                        destinationPath = Path.Combine(destinationFolder, $"{baseName}_{DateTime.Now.Ticks}{ext}");
                    }
                    File.Move(filePath, destinationPath);
                }
            }
            catch (Exception ex) when (ex is not OperationCanceledException)
            {
                preview.HasError = true;
                preview.ErrorMessage = ex.Message;
            }
            finally
            {
                preview.IsProcessing = false;
                Interlocked.Increment(ref processedCount);
                await InvokeAsync(StateHasChanged);
            }
        });
    }
    #endregion

    #region Helper Methods

    // --- NEW: Section 3 - Add the method to handle the button click ---
    private void OpenResultsFolder()
    {
        if (string.IsNullOrEmpty(outputFolderPath) || !Directory.Exists(outputFolderPath))
        {
            errorMessage = "Output folder is not valid or does not exist.";
            return;
        }

        try
        {
            // This command tells the operating system to open the folder in its default file explorer
            Process.Start(new ProcessStartInfo
            {
                FileName = outputFolderPath,
                UseShellExecute = true
            });
        }
        catch (Exception ex)
        {
            errorMessage = $"Could not open folder: {ex.Message}";
        }
    }

    // (No changes to the other helper methods)
    private (int width, int height) GetImageDimensionsFromBytes(byte[] imageBytes) { try { using var ms = new MemoryStream(imageBytes); using var image = System.Drawing.Image.FromStream(ms, false, false); return (image.Width, image.Height); } catch { return (0, 0); } }
    private void SelectPreview(int index) => selectedIndex = index;
    private void ClearError() => errorMessage = "";
    private string GetSummaryClass(string? label) => label?.ToLower() switch { "good" => "good", "bad" => "bad", "duplicate" => "duplicate", "closed eye" => "closed-eye", _ => "" };
    private string GetBadgeClass(string? label) => label?.ToLower() switch { "good" => "badge-good", "bad" => "badge-bad", "duplicate" => "badge-duplicate", "closed eye" => "badge-closed-eye", _ => "badge-default" };
    private string FormatFileSize(long bytes) { if (bytes < 0) return "0 B"; string[] sizes = { "B", "KB", "MB", "GB" }; int order = 0; double size = bytes; while (size >= 1024 && order < sizes.Length - 1) { order++; size /= 1024; } return $"{size:0.##} {sizes[order]}"; }
    #endregion
}